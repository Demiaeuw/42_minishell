
// int open_file(t_chevron *chevron)
// {
//     int fd;

//     if (chevron->type == OUT)
//         fd = open(chevron->file_name, O_WRONLY | O_CREAT | O_TRUNC, 0644);
//     else if (chevron->type == DOUBLE_OUT)
//         fd = open(chevron->file_name, O_WRONLY | O_CREAT | O_APPEND, 0644);
//     else if (chevron->type == IN)
//         fd = open(chevron->file_name, O_RDONLY);
//     else if (chevron->type == DOUBLE_IN)
//         fd = -1;
//     else
//         fd = -1;
//     if (fd < 0)
//         perror("open_file error");
//     else
//     return fd;
// }

// void	handle_redirections(t_token *token)
// {
// 	t_chevron	*current;
// 	int			fd_in = -1;
// 	int			fd_out = -1;

// 	current = token->file_in_out;
// 	while (current)
// 	{
// 		if (current->type == IN || current->type == DOUBLE_IN)
// 		{
// 			if (fd_in != -1)
// 				close(fd_in);
// 			fd_in = open_file(current);
// 			if (fd_in == -1)
// 				return ;
// 			dup2(fd_in, STDIN_FILENO);
// 		}
// 		else if (current->type == OUT || current->type == DOUBLE_OUT)
// 		{
// 			if (fd_out != -1)
// 				close(fd_out);
// 			fd_out = open_file(current);
// 			if (fd_out == -1)
// 				return ;
// 			dup2(fd_out, STDOUT_FILENO);
// 		}
// 		current = current->next;
// 	}
// }

FONCTION ADRI UTILE ?

char	*truncate_str_chevron(char *str)
{
	int		i;
	char	*new_str;

	i = 0;
	while (str[i])
	{
		if ((str[i] == '<' && str[i + 1] == '<') || (str[i] == '>'
				&& str[i + 1] == '>'))
			break ;
		if (str[i] == '<' || str[i] == '>')
			break ;
		i++;
	}
	new_str = (char *)malloc(sizeof(char) * (i + 1));
	if (!new_str)
		return (NULL);
	i = 0;
	while (str[i] && !(str[i] == '<' || str[i] == '>'))
	{
		new_str[i] = str[i];
		i++;
	}
	new_str[i] = '\0';
	return (new_str);
}

//////////////////////EXPORT FONCTIONNEL MAIS BORDEL///////////////////////////

#include "../../include/minishell.h"
// Sets a new env variable or updates an existing one
// void	set_env_var(t_envp *envp, const char *var, const char *value)
// {
// 	int		var_len;
// 	char	*new_entry;

// 	var_len = ft_strlen(var);
// 	new_entry = create_env_entry(var, value);
// 	if (!new_entry)
// 		return ;
// 	update_env(envp, var, var_len, new_entry);
// }
// void set_env_var(t_envp *envp, const char *var, const char *value) {
//     int var_len = ft_strlen(var);
//     char *new_entry;

//     if (!value) {
//         value = "";
//     }

//     // Créer la nouvelle entrée (var=value)
//     new_entry = create_env_entry(var, value);
//     if (!new_entry) {
//         return;
//     }

//     // Mettre à jour la variable si elle existe déjà
//     for (int i = 0; envp->env[i]; i++) {
//         if (ft_strncmp(envp->env[i], var, var_len) == 0 && envp->env[i][var_len] == '=') {
//             // Remplacer l'ancienne valeur par la nouvelle
//             free(envp->env[i]);
//             envp->env[i] = new_entry;
//             return;
//         }
//     }

//     // Si la variable n'existe pas, l'ajouter
//     add_env_variable(envp, new_entry);
// }
// void set_env_var(t_envp *envp, const char *var, const char *value) {
//     int var_len;
//     char *new_entry;

//     if (!value) {
//         // Si value est NULL, on veut juste ajouter la variable sans la valeur
//         new_entry = ft_strdup(var);  // Crée une entrée sans '='
//     } else {
//         var_len = ft_strlen(var);
//         new_entry = create_env_entry(var, value);
//     }

//     if (!new_entry)
//         return;

//     update_env(envp, var, var_len, new_entry);
// }
void set_env_var(t_envp *envp, const char *var, const char *value) {
    int var_len;
    char *new_entry;
    int i = 0;

    var_len = ft_strlen(var);

    if (value == NULL) {
        // Si value est NULL, on ne doit pas ajouter "=" après la variable
        new_entry = ft_strdup(var);  // Crée une nouvelle entrée sans '='
    } else {
        new_entry = create_env_entry(var, value);  // Crée une entrée avec '=' et la valeur
    }

    if (!new_entry)
        return;

    // Rechercher si la variable existe déjà
    while (envp->env[i]) {
        // Comparer seulement le nom de la variable, pas la valeur
        if (ft_strncmp(envp->env[i], var, var_len) == 0 && (envp->env[i][var_len] == '=' || envp->env[i][var_len] == '\0')) {
            // Si elle existe, mettre à jour la variable existante
            free(envp->env[i]);
            envp->env[i] = new_entry;
            return;
        }
        i++;
    }

    // Si la variable n'existe pas, l'ajouter
    add_env_variable(envp, new_entry);
}
// Updates the env with the new entry or adds it if it doesn't exist
void	update_env(t_envp *envp, const char *var, int var_len, char *new_entry)
{
	int	i;

	i = 0;
	while (envp->env[i])
	{
		if (ft_strncmp(envp->env[i], var, var_len) == 0
			&& envp->env[i][var_len] == '=')
		{
			free(envp->env[i]);
			envp->env[i] = new_entry;
			return ;
		}
		i++;
	}
	add_env_variable(envp, new_entry);
}

// Processes an export token and adds or updates the corresponding env variable
// void	process_export_token(t_envp *envp, char *token)
// {
// 	char	*equal_sign;
// 	char	*var;
// 	char	*value;

// 	equal_sign = ft_strchr(token, '=');
// 	if (!equal_sign)
// 		return ;
// 	var = ft_strndup(token, equal_sign - token);
// 	value = equal_sign + 1;
// 	if (var && *var)
// 		set_env_var(envp, var, value);
// 	free(var);
// }
int is_var_in_env(t_envp *envp, const char *var) {
    int i = 0;
    size_t var_len = ft_strlen(var);

    while (envp->env[i]) {
        if (ft_strncmp(envp->env[i], var, var_len) == 0 && envp->env[i][var_len] == '=') {
            return 1; // La variable existe déjà
        }
        i++;
    }
    return 0; // La variable n'existe pas
}
void process_export_token(t_envp *envp, char *token) {
    char *equal_sign = ft_strchr(token, '=');
    char *var;

    if (equal_sign) {
        // S'il y a un signe égal, ajouter la variable avec la valeur donnée
        var = ft_strndup(token, equal_sign - token);
        if (var && *var) {
            set_env_var(envp, var, equal_sign + 1);  // valeur après '=' ou ""
        }
        free(var);
    } else {
        // Sinon, juste ajouter la variable sans valeur
        if (!is_var_in_env(envp, token)) {
            set_env_var(envp, token, NULL);  // Pas de valeur pour 'salut'
        }
    }
}
// void process_export_token(t_envp *envp, char *token) {
//     char *equal_sign = ft_strchr(token, '=');
//     char *var;

//     if (equal_sign) {
//         // Si un signe égal est présent, traiter comme une variable avec une valeur
//         var = ft_strndup(token, equal_sign - token);
//         if (var && *var) {
//             set_env_var(envp, var, equal_sign + 1);  // Mise à jour ou ajout de la variable
//         }
//         free(var);
//     } else {
//         // Pas de signe égal, ajouter la variable sans valeur (NULL)
//         // Vérifier si la variable existe déjà
//         if (is_var_in_env(envp, token)) {
//             // Si la variable existe déjà sans valeur, ne rien faire
//             return;
//         }
//         set_env_var(envp, token, NULL);  // Ajouter la variable sans valeur
//     }
// }
// Executes the export command to add or update env variables
// void	exe_export(t_envp *envp, char *args)
// {
// 	char	*token;
// 	char	*saveptr;

// 	if (!args)
// 		return ;
// 	if (ft_strncmp(args, "export ", 7) == 0)
// 		args += 7;
// 	token = ft_strtok(args, " ", &saveptr);
// 	while (token != NULL)
// 	{
// 		process_export_token(envp, token);
// 		token = ft_strtok(NULL, " ", &saveptr);
// 	}
// }

int	compare_env_vars(const void *a, const void *b)
{
	const char *env1;
	const char *env2;

	env1 = *(const char **)a;
	env2 = *(const char **)b;
	return ft_strcmp(env1, env2);
}

// Function to print the env variables in the format `declare -x VAR="value"`
// void	print_sorted_env(char **env)
// {
// 	int i, size;

// 	size = get_env_size(env);

// 	// Copy environment variables to a temporary array for sorting
// 	char **sorted_env = malloc(size * sizeof(char *));
// 	if (!sorted_env)
// 		return;
// 	for (i = 0; i < size; i++) {
// 		sorted_env[i] = env[i];
// 	}

// 	// Sort the environment variables
// 	qsort(sorted_env, size, sizeof(char *), compare_env_vars);

// 	// Print each environment variable in the desired format
// 	for (i = 0; i < size; i++) {
// 		printf("declare -x %s\n", sorted_env[i]);
// 	}

// 	free(sorted_env);
// }
void print_sorted_env(char **env) {
    int i, size;

    size = get_env_size(env);

    // Copier les variables d'environnement dans un tableau temporaire pour les trier
    char **sorted_env = malloc(size * sizeof(char *));
    if (!sorted_env)
        return;
    for (i = 0; i < size; i++) {
        sorted_env[i] = env[i];
    }

    // Trier les variables d'environnement
    qsort(sorted_env, size, sizeof(char *), compare_env_vars);

    // Afficher chaque variable d'environnement dans le format désiré
    for (i = 0; i < size; i++) {
        char *equal_sign = ft_strchr(sorted_env[i], '=');

        if (equal_sign == NULL) {
            // Si aucun signe égal n'est trouvé, la variable n'a pas de valeur
            printf("declare -x %s\n", sorted_env[i]);
        } else if (equal_sign[1] == '\0') {
            // Variable avec une valeur vide, afficher comme nom=""
            printf("declare -x %.*s=\"\"\n", (int)(equal_sign - sorted_env[i]), sorted_env[i]);
        } else {
            // Afficher la variable avec sa valeur normale
            printf("declare -x %s\n", sorted_env[i]);
        }
    }

    free(sorted_env);
}
// Executes the export command to add or update env variables or list them
void	exe_export(t_envp *envp, char *args)
{
	char *token;
	char *saveptr;

	if (!args || ft_strcmp(args, "export") == 0) {
		// If no arguments are provided, list the environment variables
		print_sorted_env(envp->env);
		return;
	}

	if (ft_strncmp(args, "export ", 7) == 0)
		args += 7;

	token = ft_strtok(args, " ", &saveptr);
	while (token != NULL) {
		process_export_token(envp, token);
		token = ft_strtok(NULL, " ", &saveptr);
    }
}

////////////////////////ANCIEN CONVERT TOKEN//////////////////////////////////
// char	**convert_token(t_token *token)
// {
// 	t_token	*current;
// 	char	**str;
// 	int		count;
// 	int		i;

// 	count = 0;
// 	current = token;
// 	while (current && current->type != TOKEN_PIPE)
// 	{
// 		count++;
// 		current = current->next;
// 	}
// 	str = (char **)safe_malloc((count + 1) * sizeof(char *));
// 	if (!str)
// 		return (NULL);
// 	i = 0;
// 	current = token;
// 	while (current && current->type != TOKEN_PIPE)
// 	{
// 		str[i] = ft_strdup(current->value);
// 		i++;
// 		current = current->next;
// 	}
// 	str[i] = NULL;
// 	return (str);
// }

//////////////////ANCIEN FILE export3//////////////////////////////////////////
// char	**allocate_and_copy_env(char **env, int size)
// {
// 	char	**sorted_env;
// 	int		i;

// 	sorted_env = malloc(size * sizeof(char *));
// 	if (!sorted_env)
// 		return (NULL);
// 	i = 0;
// 	while (i < size)
// 	{
// 		sorted_env[i] = env[i];
// 		i++;
// 	}
// 	return (sorted_env);
// }

// void	print_env_var(char *env_var)
// {
// 	char	*equal_sign;

// 	equal_sign = ft_strchr(env_var, '=');
// 	if (equal_sign == NULL)
// 		printf("declare -x %s\n", env_var);
// 	else if (equal_sign[1] == '\0')
// 		printf("declare -x %.*s=\"\"\n", (int)(equal_sign - env_var), env_var);
// 	else
// 		printf("declare -x %s\n", env_var);
// }

// void	print_sorted_env(char **env)
// {
// 	int		i;
// 	int		size;
// 	char	**sorted_env;

// 	size = get_env_size(env);
// 	sorted_env = allocate_and_copy_env(env, size);
// 	if (!sorted_env)
// 		return ;
// 	qsort(sorted_env, size, sizeof(char *), compare_env_vars);
// 	i = 0;
// 	while (i < size)
// 	{
// 		print_env_var(sorted_env[i]);
// 		i++;
// 	}
// 	free(sorted_env);
// }

///// ANCIEN BUITIN SELECTOR CHEVRON ///////////

// void	builtin_selector_chevron(t_token *token, t_envp *envp)
// {
// 	if (!ft_strcmp("cd", token->builtin_info))
// 		exe_cd(token->file_in_out->value, envp);
// 	if (!ft_strcmp("echo", token->builtin_info))
// 		exe_echo(token->file_in_out->value);
// 	else if (!ft_strcmp("env", token->builtin_info))
// 		mini_env(envp);
// 	else if (!ft_strcmp("export", token->builtin_info))
// 		exe_export(envp, token->file_in_out->value);
// 	else if (!ft_strcmp("unset", token->builtin_info))
// 		exe_unset(envp, token->file_in_out->value);
// 	else if (!ft_strcmp("pwd", token->builtin_info))
// 		exe_pwd();
// 	else if (!ft_strcmp("exit", token->builtin_info))
// 		exe_exit(token->file_in_out->value, envp, token);
// }

////// ANCIEN CREATE CHILD PROCESS ////////////

// void	create_child_process(t_token *token, t_envp *envp, t_signal *handler, int in, int out)
// {
// 	pid_t pid;

// 	if (builtin_check(token))
// 		builtin_selector_chevron(token, envp);
// 	else
// 	{
// 		pid = fork();
// 		if (pid < 0)
// 		{
// 			perror("fork error");
// 			exit(EXIT_FAILURE);
// 		}
// 		else if (pid == 0)
// 		{
// 			file_descriptor_handler(in, out);
// 			handle_redirections(token->file_in_out);
// 			execute_execve(token, envp, handler);
// 			exit(EXIT_FAILURE);
// 		}
// 		else
// 		{
// 			waitpid(pid, &handler->sigterm, WUNTRACED);
// 			handle_signals_in_parent(handler);
// 			if (WIFSIGNALED(handler->sigterm))
// 				handler->sigterm = WTERMSIG(handler->sigterm) + 128;
// 			else if (WIFEXITED(handler->sigterm))
// 				handler->sigterm = WEXITSTATUS(handler->sigterm);
// 		}
// 	}
// }

////////ancien main command chevron//////////////////

// void	main_command_chevron(t_token *token, t_envp *envp, t_signal *handler)
// {
// 	t_token	*current;
// 	int		saved_stdin;
// 	int		saved_stdout;

// 	current = token;
// 	saved_stdin = dup(STDIN_FILENO);
// 	saved_stdout = dup(STDOUT_FILENO);
// 	while (current != NULL)
// 	{
// 		if (current->type == TOKEN_COMMAND || current->type == TOKEN_PIPE)
// 		{
// 			create_child_process(current, envp, handler, saved_stdin, saved_stdout);
// 			dup2(saved_stdin, STDIN_FILENO);
// 			dup2(saved_stdout, STDOUT_FILENO);
// 		}
// 		current = current->next;
// 	}
// 	close(saved_stdin);
// 	close(saved_stdout);
// }

//////////////////ancien prepare command//////////////


// int	prepare_command(char ***split_args, char ***args, t_token *token)
// {
// 	*split_args = split_command(token->value);
// 	if (!*split_args)
// 		return (0);
// 	for (int i = 0; (*split_args)[i] != NULL; i++)
// 	{
// 		if ((ft_strcmp((*split_args)[i], "<<") == 0) ||
// 			(token->file_in_out != NULL && token->file_in_out->value != NULL &&
// 				ft_strcmp((*split_args)[i], token->file_in_out->value) == 0))
// 		{
// 			(*split_args)[i] = NULL;
// 			break ;
// 		}
// 	}
// 	*args = convert_token(token);
// 	if (!*args)
// 	{
// 		handle_memory_error(*split_args, NULL);
// 		return (0);
// 	}
// 	return (1);
// }
