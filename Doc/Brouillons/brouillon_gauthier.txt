ANCIEN EXEC EXECVE FONCTIONNEL

// char	**split_command(const char *cmd)
// {
// 	char	**args;
// 	int		count;
// 	int		i;
// 	char	*cmd_copy;
// 	char	*token;

// 	count = 0;
// 	cmd_copy = ft_strdup(cmd);
// 	token = strtok(cmd_copy, " ");
// 	while (token)
// 	{
// 		count++;
// 		token = strtok(NULL, " ");
// 	}
// 	free(cmd_copy);
// 	args = (char **)malloc((count + 1) * sizeof(char *));
// 	if (!args)
// 		return (NULL);
// 	i = 0;
// 	cmd_copy = ft_strdup(cmd);
// 	token = strtok(cmd_copy, " ");
// 	while (token)
// 	{
// 		args[i] = ft_strdup(token);
// 		i++;
// 		token = strtok(NULL, " ");
// 	}
// 	args[i] = NULL;
// 	free(cmd_copy);
// 	return (args);
// }

void	execute_execve(t_token *token, char **env)
{
	pid_t	pid;
	int		status;
	char	**args;
	char	*cmd_path;
	char	**split_args;

	split_args = split_command(token->value);
	if (!split_args)
	{
		perror("Memory allocation failed");
		return ;
	}

	args = convert_token(token);
	if (!args)
	{
		perror("Memory allocation failed");
		free(split_args);
		return ;
	}
	cmd_path = get_command_path(split_args[0]);
	if (!cmd_path)
	{
		fprintf(stderr, "Command not found: %s\n", split_args[0]);
		free(split_args);
		free(args);
		return ;
	}
	pid = fork();
	if (pid == -1)
	{
		perror("fork");
		free(split_args);
		free(args);
		free(cmd_path);
		return ;
	}
	else if (pid == 0)
	{
		if (execve(cmd_path, split_args, env) == -1)
		{
			perror("execve");
			exit(EXIT_FAILURE);
		}
	}
	else
		waitpid(pid, &status, 0);
	free(split_args);
	free(args);
	free(cmd_path);
}
