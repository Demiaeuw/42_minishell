Pour commencer le parsing de votre shell Minishell, nous allons aborder cela étape par étape. Voici un plan structuré pour vous guider tout au long du processus :
Étape 1 : Comprendre les objectifs du parsing

Le parsing dans un shell consiste à analyser l'entrée de l'utilisateur, à diviser cette entrée en commandes et arguments, puis à exécuter les commandes en conséquence. Voici les tâches principales :

    Lire l'entrée de l'utilisateur.
    Gérer les caractères spéciaux comme les espaces, les guillemets, les pipes (|), les redirections (>, <).
    Diviser l'entrée en commandes et arguments.
    Gérer les variables d'environnement et les expansions.

Étape 2 : Lire l'entrée de l'utilisateur

Pour lire l'entrée, vous pouvez utiliser la fonction readline de la bibliothèque Readline, comme vu précédemment.

Étape 3 : Tokenization

Le tokenization est le processus de division de la chaîne d'entrée en morceaux significatifs appelés "tokens". Voici comment vous pouvez procéder :

    Supprimer les espaces superflus : Éliminez les espaces en début et en fin de ligne.
    Gérer les guillemets : Traitez les guillemets simples (') et doubles ("), qui permettent de regrouper des chaînes de caractères contenant des espaces.
    Détecter les opérateurs : Identifiez et séparez les opérateurs comme |, >, <.

Exemple de code de tokenization :

c```

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Structure de token
typedef struct s_token {
    char *value;
    struct s_token *next;
} t_token;

// Fonction pour créer un nouveau token
t_token *new_token(char *value) {
    t_token *token = malloc(sizeof(t_token));
    token->value = strdup(value);
    token->next = NULL;
    return token;
}

// Fonction de tokenization de base
t_token *tokenize(char *input) {
    t_token *head = NULL;
    t_token *current = NULL;
    char *token = strtok(input, " ");

    while (token != NULL) {
        t_token *new = new_token(token);
        if (head == NULL) {
            head = new;
            current = head;
        } else {
            current->next = new;
            current = current->next;
        }
        token = strtok(NULL, " ");
    }
    return head;
}

// Fonction pour afficher les tokens
void print_tokens(t_token *tokens) {
    while (tokens != NULL) {
        printf("Token: %s\n", tokens->value);
        tokens = tokens->next;
    }
}

int main() {
    char input[] = "ls -l | grep minishell > output.txt";
    t_token *tokens = tokenize(input);
    print_tokens(tokens);
    return 0;
}
```

Étape 4 : Analyse syntaxique

Après la tokenization, vous devez analyser la syntaxe des commandes. Cela implique de comprendre la structure des commandes et de vérifier la validité syntaxique.
Étape 5 : Gérer les opérateurs et les redirections

Les opérateurs de pipe (|) et de redirection (>, <) doivent être identifiés et traités correctement pour créer des structures de commandes exécutables.
Étape 6 : Expansion des variables et substitution

Implémentez la gestion des variables d'environnement ($VAR) et la substitution de commande.
Étape 7 : Exécution des commandes

Utilisez les fonctions fork, exec, et wait pour exécuter les commandes parsées.
Conseils pratiques

    Utilisez une structure de données pour représenter les commandes et leurs arguments.
    Traitez les erreurs de manière robuste pour gérer les entrées utilisateur incorrectes.
    Testez chaque étape avec des entrées simples avant de passer à des cas plus complexes.

En suivant ces étapes, vous pouvez structurer votre projet de parsing dans Minishell de manière efficace.




<------------------------------------------------------------------------------------------------------------------------------------------------------->

Pour la commande in (<) et heardoc (<<) : si pas d'argument c'est uniquement la  dernière redirection qui est pris en compte 
ex : cat salut < blalbal << troue < du 				--> salut
ex : cat < vlalv << dedef < trefzsdvc < hello 		--> hello


pout les output (>) et append (>>) ils doivent tous etre géré dans l'ordre.

<------------------------------------------------------------------------------------------------------------------------------------------------------->

faire de nombreux test pour la gestion des " et ' pour bien l'implémenter

```
acabarba@AdrienSurface:~$ echo $?
0
acabarba@AdrienSurface:~$ echo '$?'
$?
acabarba@AdrienSurface:~$ echo "$?"
0
```

<------------------------------------------------------------------------------------------------------------------------------------------------------->


Quand parser finit : free tous les tokens



https://excalidraw.com/#json=hRZyYLWPN4teAwVmhpqPS,4MUN8zVpbjeSSEQp0EfCGg




<------------------------------------------------------------------------------------------------------------------------------------------------------->



verifier le token is_last_command !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!